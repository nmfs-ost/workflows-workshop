#' Map Legacy AutoUpdate RData to stockplotr Structure
#'
#' This function acts as a bridge between the legacy assessment report environment 
#' and the standardized asar_stock format. It extracts model results, catch, 
#' surveys, projections, and reference points, while preserving metadata as attributes.
#'
#' @param rdata_path Character string; path to the .RData file generated by the legacy report software.
#'
#' @return A tibble with the standardized stockplotr columns. Attributes include:
#' \itemize{
#'   \item \code{metadata}: A list of stock names, report years, and table/figure captions.
#'   \item \code{legacy_brp}: A sidecar data frame containing raw biological reference point strings.
#' }
#' 
#' @details The function uses explicit lookup for survey CVs based on the \code{SurveyN.CV} 
#'          convention found in the legacy environment. It also performs regex cleaning 
#'          on projection strings to extract high/low confidence bounds.
#'
#' @export
#_______________________________________________________________________________
map_autoUpdate_to_stockplotr <- function(rdata_path = "AutoAss.RData") {
  
  legacy_env <- new.env()
  load(rdata_path, envir = legacy_env)
  
  # Convert matrices to data frames
  dt2_df <- as.data.frame(legacy_env$dt2)
  dt1_df <- as.data.frame(legacy_env$dt1)
  dt3_df <- as.data.frame(legacy_env$dt3)
  
  # Define the standard stockplotr structure
  out_new <- data.frame(
    module_name = character(), label = character(), time = character(), 
    era = character(), year = numeric(), month = numeric(), 
    season = numeric(), subseason = numeric(), birthseas = numeric(), 
    initial = numeric(), estimate = numeric(), uncertainty = numeric(), 
    uncertainty_label = character(), likelihood = numeric(), 
    fleet = character(), platoon = character(), area = character(), 
    age = character(), sex = character(), growth_pattern = character(), 
    bio_pattern = character(), settlement = character(), 
    morph = character(), type = character(), factor = character(), 
    part = character(), kind = character(), nsim = numeric(), 
    bin = numeric(), age_a = character(), len_bins = character(), 
    count = numeric(), block = character(),
    estimate_chr = character() # Added to store pre-formatted strings
  )
  
  # Map Model Results
  model_results <- dt2_df |>
    tidyr::pivot_longer(
      cols = tidyselect::any_of(c(legacy_env$ModSSB, legacy_env$FF, legacy_env$Recruits)),
      names_to = "legacy_label",
      values_to = "estimate"
    ) |>
    dplyr::mutate(
      module_name = "model_results",
      era = "time",
      year = as.numeric(Year),
      label = dplyr::case_when(
        legacy_label == legacy_env$ModSSB ~ "biomass",
        legacy_label == legacy_env$FF ~ "fishing_mortality",
        legacy_label == legacy_env$Recruits ~ "recruitment",
        TRUE ~ legacy_label
      ),
      uncertainty = dplyr::case_when(
        legacy_label == legacy_env$ModSSB ~ dt2_df[[legacy_env$ModSSB.CV]][match(Year, dt2_df$Year)],
        legacy_label == legacy_env$FF ~ dt2_df[[legacy_env$FF.CV]][match(Year, dt2_df$Year)],
        legacy_label == legacy_env$Recruits ~ dt2_df[[legacy_env$Recruits.CV]][match(Year, dt2_df$Year)],
        TRUE ~ as.numeric(NA)
      ),
      uncertainty_label = "cv"
    )
  
  # Map Previous Assessment Results
  old_cols_to_pivot <- c(legacy_env$SSB.old, legacy_env$F.old, legacy_env$Recruits.old)
  old_cols_present <- old_cols_to_pivot[old_cols_to_pivot %in% colnames(dt2_df)]
  
  if (length(old_cols_present) > 0) {
    ssb_old_lab  <- legacy_env$SSB.old      %||% "___MISSING___"
    f_old_lab    <- legacy_env$F.old        %||% "___MISSING___"
    rec_old_lab  <- legacy_env$Recruits.old %||% "___MISSING___"
    
    model_old <- dt2_df |>
      tidyr::pivot_longer(
        cols = tidyselect::all_of(old_cols_present),
        names_to = "legacy_label",
        values_to = "estimate"
      ) |>
      dplyr::mutate(
        module_name = "model_results",
        era = "prev", 
        year = as.numeric(Year),
        label = dplyr::case_when(
          legacy_label == ssb_old_lab  ~ "biomass",
          legacy_label == f_old_lab    ~ "fishing_mortality",
          legacy_label == rec_old_lab  ~ "recruitment",
          TRUE ~ legacy_label
        ),
        uncertainty = NA_real_,
        uncertainty_label = "cv"
      )
    model_results <- dplyr::bind_rows(model_results, model_old)
  }
  
  # Map Catch Data
  fleet_indices <- 1:8
  fleet_cols <- purrr::map_chr(fleet_indices, ~ legacy_env[[paste0("Fleet", .x)]] %||% NA_character_)
  fleet_names <- purrr::map_chr(fleet_indices, ~ legacy_env[[paste0("Fleet", .x, ".name")]] %||% NA_character_)
  fleet_map <- stats::setNames(fleet_names, fleet_cols)
  fleet_map <- fleet_map[!is.na(names(fleet_map))]
  
  catch_results <- dt1_df |>
    tidyr::pivot_longer(
      cols = tidyselect::any_of(c(names(fleet_map), legacy_env$Total)),
      names_to = "legacy_fleet_id",
      values_to = "estimate"
    ) |>
    dplyr::mutate(
      module_name = "catch",
      era = "time",
      year = as.numeric(Year),
      label = "total_catch",
      fleet = dplyr::case_when(
        legacy_fleet_id == legacy_env$Total ~ "Total",
        legacy_fleet_id %in% names(fleet_map) ~ fleet_map[legacy_fleet_id],
        TRUE ~ legacy_fleet_id
      )
    )
  
  # Map Survey Data
  survey_indices <- 1:8
  survey_cols <- purrr::map_chr(survey_indices, ~ legacy_env[[paste0("Survey", .x)]] %||% NA_character_)
  survey_cv_cols <- purrr::map_chr(survey_indices, ~ legacy_env[[paste0("Survey", .x, ".CV")]] %||% NA_character_)
  survey_names <- purrr::map_chr(survey_indices, ~ legacy_env[[paste0("Survey", .x, ".name")]] %||% NA_character_)
  
  surv_map <- stats::setNames(survey_names, survey_cols)
  surv_map <- surv_map[!is.na(names(surv_map))]
  cv_lookup <- stats::setNames(survey_cv_cols, survey_cols)
  cv_lookup <- cv_lookup[!is.na(names(cv_lookup))]
  
  survey_results <- dt3_df |>
    tidyr::pivot_longer(
      cols = tidyselect::any_of(names(surv_map)),
      names_to = "legacy_survey_id",
      values_to = "estimate"
    ) |>
    dplyr::mutate(
      module_name = "survey",
      era = "time",
      year = as.numeric(Year),
      label = "index",
      fleet = surv_map[legacy_survey_id],
      cv_col_to_pull = cv_lookup[legacy_survey_id]
    ) |>
    dplyr::rowwise() |>
    dplyr::mutate(
      uncertainty = if (!is.na(cv_col_to_pull) && cv_col_to_pull %in% colnames(dt3_df)) {
        as.numeric(dt3_df[dt3_df$Year == Year, cv_col_to_pull])
      } else {
        as.numeric(NA)
      },
      uncertainty_label = "cv"
    ) |>
    dplyr::ungroup() |>
    dplyr::select(-cv_col_to_pull)
  
  # REVISED Projection Logic for Butterfish/Surfclam
  projection_results <- data.frame(
    year = as.numeric(legacy_env$PYear),
    catch_raw = as.character(legacy_env$PCatch),
    ssb_raw = as.character(legacy_env$PSSB),
    f_raw = as.character(legacy_env$PF)
  ) |>
    dplyr::rowwise() |>
    dplyr::mutate(
      # Safely extract numeric estimate and uncertainty bounds for SSB
      ssb_est = as.numeric(gsub(",", "", stringr::str_extract(ssb_raw, "^[^ ]+"))),
      ssb_lo  = as.numeric(gsub(",", "", stringr::str_extract(ssb_raw, "(?<=\\()[0-9,]+(?= -)"))),
      ssb_hi  = as.numeric(gsub(",", "", stringr::str_extract(ssb_raw, "(?<=- )[0-9,]+(?=\\))"))),
      
      # Safely extract numeric estimate for Catch (handles strings with parentheses)
      catch_est = as.numeric(gsub(",", "", stringr::str_extract(catch_raw, "^[^ ]+"))),
      
      # Safely extract numeric estimate for F
      f_est = as.numeric(gsub(",", "", f_raw))
    ) |>
    dplyr::ungroup() |>
    tidyr::pivot_longer(
      cols = c(catch_est, ssb_est, f_est),
      names_to = "proj_label",
      values_to = "estimate"
    ) |>
    dplyr::mutate(
      module_name = "projections",
      era = "fore",
      label = dplyr::case_when(
        proj_label == "catch_est" ~ "total_catch",
        proj_label == "ssb_est" ~ "biomass",
        proj_label == "f_est" ~ "fishing_mortality"
      ),
      # Save the raw formatted strings into estimate_chr to preserve parentheses
      estimate_chr = dplyr::case_when(
        label == "total_catch" ~ catch_raw,
        label == "biomass" ~ ssb_raw,
        label == "fishing_mortality" ~ f_raw
      )
    )
  
  # Capture SSB uncertainty bounds
  proj_uncertainty <- projection_results |>
    dplyr::filter(label == "biomass") |>
    tidyr::pivot_longer(
      cols = c(ssb_lo, ssb_hi),
      names_to = "u_label",
      values_to = "u_val"
    ) |>
    dplyr::mutate(
      uncertainty = u_val,
      uncertainty_label = dplyr::if_else(u_label == "ssb_lo", "low", "high")
    ) |>
    dplyr::select(year, label, uncertainty, uncertainty_label)
  
  projection_results <- projection_results |>
    dplyr::left_join(proj_uncertainty, by = c("year", "label")) |>
    dplyr::select(-c(catch_raw, ssb_raw, f_raw, proj_label, ssb_lo, ssb_hi))
  
  # Map Biological Reference Points
  ref_map <- c(
    "biomass_msy"                 = "SSBMSYpt.est", 
    "biomass_target"              = "SSBtarget",
    "biomass_threshold"           = "SSBthreshold",
    "fishing_mortality_msy"       = "FMSYpt.est",   
    "fishing_mortality_target"    = "Ftarget",
    "fishing_mortality_threshold" = "Fthreshold",
    "msy"                         = "MSY",
    "median_recruits"             = "Recr"
  )
  
  if (!is.null(legacy_env$SSBMSY)) ref_map["biomass_msy"] <- "SSBMSY"
  if (!is.null(legacy_env$FMSY))   ref_map["fishing_mortality_msy"] <- "FMSY"
  
  legacy_sidecar <- purrr::map_df(names(ref_map), function(lab) {
    raw_val <- legacy_env[[ref_map[lab]]]
    if (is.null(raw_val)) return(NULL)
    data.frame(
      label = lab,
      val = as.character(raw_val),
      era = if(length(raw_val) == 2) c("prev", "current") else "current"
    )
  })
  
  reference_results <- purrr::map_df(names(ref_map), function(lab) {
    raw_val <- legacy_env[[ref_map[lab]]]
    if (is.null(raw_val)) return(NULL)
    current_str <- if(length(raw_val) == 2) raw_val[2] else raw_val[1]
    data.frame(
      label = lab,
      module_name = "reference_points",
      era = "time",
      year = NA_real_,
      estimate = as.numeric(stringr::str_extract(gsub(",", "", current_str), "[-+]?[0-9]*\\.?[0-9]+")),
      estimate_chr = as.character(current_str)
    )
  })
  
  # Final Combination
  final_out <- dplyr::bind_rows(
    model_results, catch_results, survey_results, projection_results, reference_results
  )
  
  final_out <- dplyr::bind_rows(out_new, final_out) |>
    dplyr::select(tidyselect::all_of(names(out_new))) |>
    tibble::as_tibble()
  
  # Extract numeric values from reference_results for easy metadata access
  # This pulls the specific estimates for SSB and F MSY
  val_ssb_msy_num <- reference_results |> 
    dplyr::filter(label == "biomass_msy") |> 
    dplyr::pull(estimate)
  
  val_f_msy_num <- reference_results |> 
    dplyr::filter(label == "fishing_mortality_msy") |> 
    dplyr::pull(estimate)
  
  # Metadata attachment
  metadata <- list(
    spp_name   = legacy_env$SppName,
    spp_latin  = legacy_env$SppLatinName,
    report_yr  = legacy_env$report.yr,
    term_yr    = legacy_env$term.yr,
    last_ass   = legacy_env$last.assessment,
    status_f_now   = legacy_env$Fstatus,
    status_ssb_now = legacy_env$Bstatus,
    status_f_old   = legacy_env$Fstatus_old,
    status_ssb_old = legacy_env$Bstatus_old,
    is_draft   = legacy_env$Draft,
    cap_brp    = legacy_env$BRPTab.cap,
    cap_status = legacy_env$CatchStatusTab.cap,
    cap_proj   = legacy_env$ProjTab.cap,
    cap_fish   = legacy_env$figFish.cap,
    cap_surv   = legacy_env$figSurv.cap,
    cap_ssb    = legacy_env$figSSB.cap,
    cap_f      = legacy_env$figF.cap,
    cap_recr   = legacy_env$figRecr.cap,
    rho_adj_used   = legacy_env$Rho.adj,
    rho_ssb_now    = legacy_env$BRho.now,
    rho_f_now      = legacy_env$FRho.now,
    rho_ssb_old    = legacy_env$BRho.old,
    rho_f_old      = legacy_env$FRho.old,
    terminal_f_adj = legacy_env$F.retro.adj,
    terminal_b_adj = legacy_env$B.retro.adj,
    f_name      = legacy_env$FMSY.name,
    ssb_name    = legacy_env$SSBMSY.name,
    msy_name    = legacy_env$MSY.name,
    recr_name   = legacy_env$BRP.Recruits.name,
    ff_name     = legacy_env$FF.name,
    mod_ssb_name  = legacy_env$ModSSB.name,
    mod_f_name    = legacy_env$FF.name,
    mod_recr_name = legacy_env$Recruits.name,
    catch_units = legacy_env$CatchUnits,
    ssb_units   = legacy_env$SSBUnits,
    recr_units  = legacy_env$RecrUnits,
    preamble    = legacy_env$Preamble,
    sos_text    = legacy_env$StateOfStock,
    proj_text   = legacy_env$Project,
    comments    = legacy_env$SpecialComments,
    references  = legacy_env$References,
    ci_method   = legacy_env$ci.method,
    ci_bounds   = legacy_env$bounds,
    val_ssb_msy    = val_ssb_msy_num,
    val_f_msy      = val_f_msy_num,
    catch_units    = legacy_env$CatchUnits,
    ssb_units      = legacy_env$SSBUnits
  )
  
  attributes(final_out)$metadata <- metadata
  attributes(final_out)$legacy_brp <- legacy_sidecar 
  
  return(final_out)
}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#' Clean Assessment LaTeX Strings for HTML Output
#'
#' Converts legacy LaTeX commands and formatting into Markdown/HTML compatible 
#' tags. This is primarily used for converting technical captions and reference 
#' point names for use in web-based reports or interactive plots.
#'
#' @param x A character vector containing LaTeX strings (e.g., \code{\\SSBMSY}, \code{\\textbf{...}}).
#'
#' @return A character vector of cleaned strings with HTML tags (e.g., \code{<i>SSB</i><sub>MSY</sub>}).
#' 
#' @details This function uses a comprehensive translation map for common fishery 
#'          reference points and Greek letters. It also handles structural LaTeX 
#'          cleaning like removing center environments and converting double 
#'          backslashes into line breaks.
#'
#' @export
#______________________________________________________________________________
clean_assessment_latex <- function(x) {
  if (is.null(x)) return(NULL)
  
  vapply(x, function(val) {
    val <- as.character(val)
    if (is.na(val) || val == "") return(val)
    
    clean_key <- gsub("\\\\|\\.tx|\\.ref", "", val)
    
    translation_map <- c(
      # Spawning Biomass and Reference Point Terms
      "SSBMSY"      = "<i>SSB</i><sub>MSY</sub>",
      "SSBMSYproxy" = "<i>SSB</i><sub>MSY</sub> <i>proxy</i>",
      "FMSY"        = "<i>F</i><sub>MSY</sub>",
      "FMSYproxy"   = "<i>F</i><sub>MSY</sub> <i>proxy</i>",
      "FMSYpr"      = "<i>F</i><sub>MSY</sub> <i>proxy</i>",
      "EMSY"        = "<i>E</i><sub>MSY</sub>",
      "EMSYproxy"   = "<i>E</i><sub>MSY</sub> <i>proxy</i>",
      "RMSY"        = "<i>R</i><sub>MSY</sub>",
      "RMSYproxy"   = "<i>R</i><sub>MSY</sub> <i>proxy</i>",
      "BMSY"        = "<i>B</i><sub>MSY</sub>",
      "BMSYproxy"   = "<i>B</i><sub>MSY</sub> <i>proxy</i>",
      "SSB0"        = "<i>SSB</i><sub>0</sub>",
      
      # SPR Reference Points
      "B30SPR"      = "<i>B</i><sub>30%SPR</sub>",
      "B35SPR"      = "<i>B</i><sub>35%SPR</sub>",
      "B40SPR"      = "<i>B</i><sub>40%SPR</sub>",
      "B45SPR"      = "<i>B</i><sub>45%SPR</sub>",
      "B50SPR"      = "<i>B</i><sub>50%SPR</sub>",
      "F30SPR"      = "<i>F</i><sub>30%SPR</sub>",
      "F35SPR"      = "<i>F</i><sub>35%SPR</sub>",
      "F40SPR"      = "<i>F</i><sub>40%SPR</sub>",
      "F45SPR"      = "<i>F</i><sub>45%SPR</sub>",
      "F50SPR"      = "<i>F</i><sub>50%SPR</sub>",
      
      # Mortality and Exploitation Rate Terms
      "FFull"       = "<i>F</i><sub>Full</sub>",
      "Favg5to7"    = "<span style='text-decoration:overline;'>F</span><sub>5-7</sub>",
      "Fbar"        = "<span style='text-decoration:overline;'>F</span>",
      "Ftarg"       = "<i>F</i><sub>Target</sub>",
      "Fthresh"     = "<i>F</i><sub>Threshold</sub>",
      "Frebuild"    = "<i>F</i><sub>Rebuild</sub>",
      "F0.1"        = "<i>F</i><sub>0.1</sub>",
      "EFull"       = "<i>E</i><sub>Full</sub>",
      "Etarg"       = "<i>E</i><sub>Target</sub>",
      "Ethresh"     = "<i>E</i><sub>Threshold</sub>",
      "Ebar"        = "<span style='text-decoration:overline;'>E</span>",
      
      # Spawning Biomass and Ratios
      "SSBbar"      = "<span style='text-decoration:overline;'>SSB</span>",
      "SSBtarg"     = "<i>SSB</i><sub>Target</sub>",
      "SSBthresh"   = "<i>SSB</i><sub>Threshold</sub>",
      "Btarg"       = "<i>B</i><sub>Target</sub>",
      "Bthresh"     = "<i>B</i><sub>Threshold</sub>",
      "Fratio"      = "<sup>F</sup>&frasl;<sub>F<sub>Threshold</sub></sub>",
      "Bratio"      = "<sup>B</sup>&frasl;<sub>B<sub>Threshold</sub></sub>",
      "Rratio"      = "<sup>R</sup>&frasl;<sub>R<sub>0</sub></sub>",
      "SSBratio"    = "<sup>SSB</sup>&frasl;<sub>SSB<sub>Threshold</sub></sub>", # Matches SSBratio.tx
      "half"        = "&frac12;",
      
      # Status Indicators
      "FStatus"     = "<i>Overfishing</i>",
      "BStatus"     = "<i>Overfished</i>",
      
      # Greek Letters
      "rho"         = "&rho;",
      "alpha"       = "&alpha;",
      "beta"        = "&beta;",
      "gamma"       = "&gamma;",
      "delta"       = "&delta;",
      "epsilon"     = "&epsilon;",
      "mu"          = "&mu;",
      "lambda"      = "&lambda;",
      "sigma"       = "&sigma;",
      "rhoSSB"      = "<i>SSB</i><sub>&rho;</sub>",
      "rhoF"        = "<i>F</i><sub>&rho;</sub>",
      "rhoB"        = "<i>B</i><sub>&rho;</sub>",
      
      # Structural and Headers
      "sosHead"     = "<b>State of Stock: </b>",
      "ProjHead"    = "<b>Projections: </b>",
      "SpecComHead" = "<b>Special Comments: </b>",
      "RefHead"     = "<b>References: </b>",
      "item"        = "&bull; ",
      "lbreak"      = "<br>",
      "mskip"       = "<br><br>",
      "indent"      = "&nbsp;&nbsp;&nbsp;&nbsp;"
    )
    
    # Static lookup
    if (clean_key %in% names(translation_map)) {
      return(translation_map[[clean_key]])
    }
    
    res <- val
    
    # Handle fractions before stripping braces
    #res <- gsub("\\\\frac\\{([^\\}]+)\\}\\{([^\\}]+)\\}", "<sup>\\1</sup>&frasl;<sub>\\2</sub>", res)
    # More aggressive fraction handler for Surfclam ratios
    res <- gsub("\\\\frac\\s*\\{([^\\}]+)\\}\\s*\\{([^\\}]+)\\}", "<sup>\\1</sup>&frasl;<sub>\\2</sub>", res)
    
    # Proxy logic
    res <- gsub("\\\\(F|SSB|B|E|R)_?\\{?MSY\\}?pr(\\.|oxy)?", "<i>\\1</i><sub>MSY</sub> <i>proxy</i>", res)
    res <- gsub("\\\\(F|SSB|B|E|R)MSYpr(\\.|oxy)?", "<i>\\1</i><sub>MSY</sub> <i>proxy</i>", res)
    
    # Standard fishery commands
    res <- gsub("\\\\FMSY", "<i>F</i><sub>MSY</sub>", res)
    res <- gsub("\\\\SSBMSY", "<i>SSB</i><sub>MSY</sub>", res)
    res <- gsub("\\\\FFull", "<i>F</i><sub>Full</sub>", res)
    
    # Structural cleanup
    res <- gsub("\\\\ref\\{[^\\}]+\\}", "", res)
    res <- gsub("\\\\label\\{[^\\}]+\\}", "", res)
    res <- gsub("\\\\begin\\{center\\}|\\\\end\\{center\\}", "", res)
    res <- gsub("\\\\textbf\\{([^\\}]+)\\}", "<b>\\1</b>", res)
    res <- gsub("\\\\textit\\{([^\\}]+)\\}", "<i>\\1</i>", res)
    
    # Line breaks
    res <- gsub("\\\\\\\\(?![a-zA-Z])", "<br>", res, perl = TRUE)
    
    # Remove remaining LaTeX symbols
    res <- gsub("\\$", "", res)
    res <- gsub("\\\\", "", res)
    res <- gsub("\\{", "", res)
    res <- gsub("\\}", "", res)
    
    # Whitespace normalization
    res <- gsub("\\s+", " ", res) 
    
    return(trimws(res))
  }, character(1), USE.NAMES = FALSE)
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



# A converter that preserves HTML logic but satisfies the LaTeX compiler for the PDF caption
# annoying to have to go both directions, but here we are.

#' Create Unicode Subscripts
#' @param text Standard text (e.g., "40")
#' @return Unicode subscript version (e.g., "₄₀")
make_subscript <- function(text) {
  chars     <- c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "e", "h", "i", "j", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u", "v", "x")
  subs      <- c("₀", "₁", "₂", "₃", "₄", "₅", "₆", "₇", "₈", "₉", "ₐ", "ₑ", "ₕ", "ᵢ", "ⱼ", "ₖ", "ₗ", "ₘ", "ₙ", "ₒ", "ₚ", "ᵣ", "ₛ", "ₜ", "ᵤ", "ᵥ", "ₓ")
  
  utf8_vec <- strsplit(as.character(text), "")[[1]]
  res <- vapply(utf8_vec, function(char) {
    idx <- match(tolower(char), chars)
    if (!is.na(idx)) subs[idx] else char
  }, character(1))
  
  return(paste(res, collapse = ""))
}

# Example usage:
# make_subscript("40") -> "₄₀"

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#' Convert Legacy LaTeX and HTML to Clean Markdown
#'
#' This function bridges legacy assessment report strings into a format 
#' compatible with Quarto rendering by converting LaTeX/HTML to Markdown.
#'
#' @param x Character vector of strings to be cleaned.
#'
#' @return A character vector of cleaned strings using Markdown syntax.
#' @export
to_latex_caption <- function(x) {
  if (is.null(x)) return(NULL)
  
  vapply(x, function(val) {
    val <- as.character(val)
    if (is.na(val) || val == "") return(val)
    
    # Extract clean key to match legacy logic
    clean_key <- gsub("\\\\|\\.tx|\\.ref", "", val)
    
    # Established Dictionary: Legacy LaTeX keys mapped to Markdown
    translation_map <- c(
      # Spawning Biomass / Reference Points
      "SSBMSY"      = "*SSB*~MSY~",
      "SSBMSYproxy" = "*SSB*~MSY~ *proxy*",
      "FMSY"        = "*F*~MSY~",
      "FMSYproxy"   = "*F*~MSY~ *proxy*",
      "FMSYpr"      = "*F*~MSY~ *proxy*",
      "EMSY"        = "*E*~MSY~",
      "EMSYproxy"   = "*E*~MSY~ *proxy*",
      "RMSY"        = "*R*~MSY~",
      "RMSYproxy"   = "*R*~MSY~ *proxy*",
      "BMSY"        = "*B*~MSY~",
      "BMSYproxy"   = "*B*~MSY~ *proxy*",
      "SSB0"        = "*SSB*~0~",
      "SSB40"       = "*SSB*~40%~",
      
      # SPR Reference Points
      "B30SPR" = "*B*~30%SPR~", "B35SPR" = "*B*~35%SPR~", "B40SPR" = "*B*~40%SPR~", 
      "B45SPR" = "*B*~45%SPR~", "B50SPR" = "*B*~50%SPR~",
      "F30SPR" = "*F*~30%SPR~", "F35SPR" = "*F*~35%SPR~", "F40SPR" = "*F*~40%SPR~", 
      "F45SPR" = "*F*~45%SPR~", "F50SPR" = "*F*~50%SPR~",
      "F30" = "*F*~30%~", "F35" = "*F*~35%~", "F40" = "*F*~40%~", "F45" = "*F*~45%~", "F50" = "*F*~50%~",
      "E30" = "*E*~30%~", "E35" = "*E*~35%~", "E40" = "*E*~40%~", "E45" = "*E*~45%~", "E50" = "*E*~50%~",
      
      # Mortality / Exploitation / Averages
      "FFull"    = "*F*~Full~",
      "Favg5to7" = "F̄~5-7~",
      "Fbar"     = "F̄",
      "Ftarg"    = "*F*~Target~",
      "Fthresh"  = "*F*~Threshold~",
      "Frebuild" = "*F*~Rebuild~",
      "F0.1"     = "*F*~0.1~",
      "EFull"    = "*E*~Full~",
      "Etarg"    = "*E*~Target~",
      "Ethresh"  = "*E*~Threshold~",
      "Erebuild" = "*E*~Rebuild~",
      "Ebar"     = "Ē",
      "SSBbar"   = "SSB̄",
      "SSBtarg"  = "*SSB*~Target~",
      "SSBthresh"= "*SSB*~Threshold~",
      "Btarg"    = "*B*~Target~",
      "Bthresh"  = "*B*~Threshold~",
      
      # Ratios / Fractions
      "Fratio"   = "*F*/*F*~Threshold~",
      "Bratio"   = "*B*/*B*~Threshold~",
      "Rratio"   = "*R*/*R*~0~",
      "SSBratio" = "*SSB*/*SSB*~Threshold~",
      "half"     = "1/2",
      "dfrac12" = "1/2",
      
      # Status / Greek
      "FStatus"  = "*Overfishing*",
      "BStatus"  = "*Overfished*",
      "rho"      = "ρ", "alpha" = "α", "beta" = "β", "gamma" = "γ", "delta" = "δ",
      "rhoSSB"   = "*SSB*~ρ~", "rhoF" = "*F*~ρ~", "rhoB" = "*B*~ρ~",
      "Linf"     = "*L*~∞~", "k" = "*k*",
      
      # Structural
      "sosHead"     = "**State of Stock:** ",
      "ProjHead"    = "**Projections:** ",
      "SpecComHead" = "**Special Comments:** ",
      "RefHead"     = "**References:** ",
      "item"        = "* ",
      "lbreak"      = "\n\n",
      "mskip"       = "\n\n",
      "indent"      = "    "
    )
    
    # Priority Match: Use exact dictionary hit first
    if (clean_key %in% names(translation_map)) {
      return(translation_map[[clean_key]])
    }
    
    res <- val
    
    # Clean up italics formatting for terms like proxy
    res <- stringr::str_replace_all(res, "\\\\textit\\{([^\\}]+)\\}", "*\\1*")
    
    # Convert remaining LaTeX subscripts to Markdown tildes
    # This targets patterns like _{40%} or _MSY
    res <- stringr::str_replace_all(res, "_\\{([^\\}]+)\\}", "~\\1~")
    res <- stringr::str_replace_all(res, "_([0-9a-zA-Z%]+)", "~\\1~")
    
    # Standardize HTML formatting to Markdown
    res <- res |>
      stringr::str_replace_all("<i>|</i>", "*") |>
      stringr::str_replace_all("<b>|</b>", "**") |>
      stringr::str_replace_all("<sub>", "~") |>
      stringr::str_replace_all("</sub>", "~")
    
    # Final strip of LaTeX symbols and braces
    res <- res |>
      stringr::str_replace_all("\\\\+FFull", "*F*~Full~") |> 
      stringr::str_replace_all("\\\\+SSBMSY", "*SSB*~MSY~") |>
      # Remove ALL remaining backslashes (no matter how many)
      stringr::str_replace_all("\\\\+", "") |> 
      # Remove empty braces and math signs
      stringr::str_replace_all("\\$|\\{\\}", "") |>
      # Remove stray braces
      stringr::str_replace_all("\\{|\\}", "") |> 
      stringr::str_replace_all("d?frac12", "1/2") 
    
    res <- res |>
      stringr::str_replace_all("\\n", " ") |>       # Remove newlines
      stringr::str_replace_all("\\s+", " ") |>      # Collapse multiple spaces
      stringr::str_replace_all(":::", "")           # Explicitly nuke any triple colons
    
    
    res <- trimws(res)
    return(if(res == "") val else res)
  }, character(1), USE.NAMES = FALSE)
}